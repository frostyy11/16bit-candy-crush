<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Candy Crush - Swap Edition</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            touch-action: none;
        }
        @keyframes particle-float {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-100px) scale(0); opacity: 0; }
        }
        .particle {
            animation: particle-float 1s ease-out forwards;
        }
        @keyframes pulse-glow {
            0%, 100% { filter: drop-shadow(0 0 5px currentColor); }
            50% { filter: drop-shadow(0 0 15px currentColor); }
        }
        .glow-pulse {
            animation: pulse-glow 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const GRID_SIZE = 8;
        const TILE_SIZE = 50;
        const CANDY_TYPES = 6;

        class SoundGenerator {
          constructor() {
            this.audioContext = null;
            this.soundEnabled = true;
          }

          init() {
            if (!this.audioContext) {
              this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
          }

          playTone(frequency, duration, type = 'sine', volume = 0.3) {
            if (!this.soundEnabled || !this.audioContext) return;

            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

            gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + duration);
          }

          playSwap() {
            this.init();
            this.playTone(400, 0.1, 'square', 0.2);
          }

          playMatch(matchCount) {
            this.init();
            const baseFreq = 600;
            const notes = [0, 200, 400, 600, 800];
            
            notes.slice(0, Math.min(matchCount, 5)).forEach((offset, i) => {
              setTimeout(() => {
                this.playTone(baseFreq + offset, 0.15, 'square', 0.25);
              }, i * 50);
            });
          }

          playCombo(comboCount) {
            this.init();
            const freq = 800 + (comboCount * 100);
            this.playTone(freq, 0.3, 'sine', 0.3);
          }

          playDrop() {
            this.init();
            const startFreq = 800;
            const endFreq = 400;
            const duration = 0.2;

            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, this.audioContext.currentTime + duration);

            gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + duration);
          }

          playSpecial() {
            this.init();
            const notes = [1047, 1319, 1568];
            notes.forEach((freq, i) => {
              setTimeout(() => {
                this.playTone(freq, 0.2, 'sine', 0.3);
              }, i * 80);
            });
          }

          playGameOver() {
            this.init();
            const notes = [800, 700, 600, 500, 400];
            notes.forEach((freq, i) => {
              setTimeout(() => {
                this.playTone(freq, 0.3, 'triangle', 0.2);
              }, i * 150);
            });
          }

          playSuccess() {
            this.init();
            const notes = [523, 659, 784, 1047];
            notes.forEach((freq, i) => {
              setTimeout(() => {
                this.playTone(freq, 0.2, 'sine', 0.2);
              }, i * 100);
            });
          }

          toggleSound() {
            this.soundEnabled = !this.soundEnabled;
            return this.soundEnabled;
          }
        }

        const CandyCrush = () => {
          const canvasRef = useRef(null);
          const soundRef = useRef(new SoundGenerator());
          const [score, setScore] = useState(0);
          const [moves, setMoves] = useState(30);
          const [dragStart, setDragStart] = useState(null);
          const [dragCurrent, setDragCurrent] = useState(null);
          const [isAnimating, setIsAnimating] = useState(false);
          const [gameOver, setGameOver] = useState(false);
          const [soundEnabled, setSoundEnabled] = useState(true);
          const [particles, setParticles] = useState([]);
          const [comboCount, setComboCount] = useState(0);
          const [flashCells, setFlashCells] = useState([]);
          const gridRef = useRef([]);
          const particleIdRef = useRef(0);

          useEffect(() => {
            initializeGrid();
          }, []);

          const initializeGrid = () => {
            const newGrid = [];
            for (let row = 0; row < GRID_SIZE; row++) {
              newGrid[row] = [];
              for (let col = 0; col < GRID_SIZE; col++) {
                newGrid[row][col] = Math.floor(Math.random() * CANDY_TYPES);
              }
            }
            gridRef.current = newGrid;
            removeInitialMatches();
          };

          const removeInitialMatches = () => {
            let hasMatches = true;
            let iterations = 0;
            while (hasMatches && iterations < 100) {
              hasMatches = false;
              const matches = findAllMatches();
              if (matches.length > 0) {
                matches.forEach(({ row, col }) => {
                  gridRef.current[row][col] = Math.floor(Math.random() * CANDY_TYPES);
                });
                hasMatches = true;
              }
              iterations++;
            }
            drawGrid();
          };

          const findAllMatches = () => {
            const matches = [];
            const marked = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));

            for (let row = 0; row < GRID_SIZE; row++) {
              for (let col = 0; col < GRID_SIZE - 2; col++) {
                const candy = gridRef.current[row][col];
                if (candy === -1) continue;

                let count = 1;
                while (col + count < GRID_SIZE && gridRef.current[row][col + count] === candy) {
                  count++;
                }

                if (count >= 3) {
                  for (let i = 0; i < count; i++) {
                    if (!marked[row][col + i]) {
                      matches.push({ row, col: col + i, type: candy, matchSize: count });
                      marked[row][col + i] = true;
                    }
                  }
                }
              }
            }

            for (let col = 0; col < GRID_SIZE; col++) {
              for (let row = 0; row < GRID_SIZE - 2; row++) {
                const candy = gridRef.current[row][col];
                if (candy === -1) continue;

                let count = 1;
                while (row + count < GRID_SIZE && gridRef.current[row + count][col] === candy) {
                  count++;
                }

                if (count >= 3) {
                  for (let i = 0; i < count; i++) {
                    if (!marked[row + i][col]) {
                      matches.push({ row: row + i, col, type: candy, matchSize: count });
                      marked[row + i][col] = true;
                    }
                  }
                }
              }
            }

            return matches;
          };

          const createParticles = (row, col, matchSize, type) => {
            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff'];
            const x = col * TILE_SIZE + TILE_SIZE / 2;
            const y = row * TILE_SIZE + TILE_SIZE / 2;
            
            const particleCount = matchSize >= 4 ? 12 : 8;
            
            for (let i = 0; i < particleCount; i++) {
              const angle = (Math.PI * 2 * i) / particleCount;
              const speed = matchSize >= 4 ? 3 : 2;
              const id = particleIdRef.current++;
              
              setParticles(prev => [...prev, {
                id,
                x,
                y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                color: colors[type],
                size: matchSize >= 4 ? 8 : 5,
                life: 1
              }]);
            }
          };

          const drawGrid = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2a1a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < GRID_SIZE; row++) {
              for (let col = 0; col < GRID_SIZE; col++) {
                const x = col * TILE_SIZE;
                const y = row * TILE_SIZE;
                
                const isFlashing = flashCells.some(cell => cell.row === row && cell.col === col);
                
                if (isFlashing) {
                  ctx.fillStyle = '#6a5a8a';
                } else {
                  ctx.fillStyle = (row + col) % 2 === 0 ? '#3a2a5a' : '#4a3a6a';
                }
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                
                ctx.strokeStyle = '#5a4a7a';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
              }
            }

            for (let row = 0; row < GRID_SIZE; row++) {
              for (let col = 0; col < GRID_SIZE; col++) {
                if (gridRef.current[row][col] !== -1) {
                  if (dragStart && dragCurrent && row === dragStart.row && col === dragStart.col) {
                    const deltaX = dragCurrent.x - (dragStart.col * TILE_SIZE + TILE_SIZE / 2);
                    const deltaY = dragCurrent.y - (dragStart.row * TILE_SIZE + TILE_SIZE / 2);
                    drawCandyWithOffset(ctx, row, col, gridRef.current[row][col], deltaX, deltaY);
                  } else {
                    drawCandy(ctx, row, col, gridRef.current[row][col]);
                  }
                }
              }
            }
          };

          const drawCandy = (ctx, row, col, type) => {
            drawCandyWithOffset(ctx, row, col, type, 0, 0);
          };

          const drawCandyWithOffset = (ctx, row, col, type, offsetX, offsetY) => {
            const x = col * TILE_SIZE + TILE_SIZE / 2 + offsetX;
            const y = row * TILE_SIZE + TILE_SIZE / 2 + offsetY;
            const size = 18;

            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff'];
            const darkColors = ['#aa0000', '#00aa00', '#0000aa', '#aaaa00', '#aa00aa', '#00aaaa'];

            const isFlashing = flashCells.some(cell => cell.row === row && cell.col === col);
            
            if (isFlashing) {
              ctx.shadowBlur = 20;
              ctx.shadowColor = colors[type];
            }

            ctx.fillStyle = colors[type];
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = darkColors[type];
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.shadowBlur = 0;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(x - 5, y - 5, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = darkColors[type];
            ctx.fillRect(x - 2, y + size - 5, 4, 2);
          };

          const getCoordinates = (e) => {
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            
            if (e.touches && e.touches.length > 0) {
              return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
              };
            } else {
              return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
              };
            }
          };

          const handleStart = (e) => {
            if (isAnimating || gameOver) return;
            e.preventDefault();

            const { x, y } = getCoordinates(e);
            const col = Math.floor(x / TILE_SIZE);
            const row = Math.floor(y / TILE_SIZE);

            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
              setDragStart({ row, col });
              setDragCurrent({ x, y });
              soundRef.current.playTone(300, 0.05, 'square', 0.15);
            }
          };

          const handleMove = (e) => {
            if (!dragStart || isAnimating || gameOver) return;
            e.preventDefault();

            const { x, y } = getCoordinates(e);
            setDragCurrent({ x, y });
          };

          const handleEnd = (e) => {
            if (!dragStart || isAnimating || gameOver) return;
            e.preventDefault();

            const coords = e.changedTouches && e.changedTouches.length > 0 
              ? getCoordinates({ touches: e.changedTouches })
              : getCoordinates(e);

            const { x, y } = coords;
            const col = Math.floor(x / TILE_SIZE);
            const row = Math.floor(y / TILE_SIZE);

            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
              const rowDiff = Math.abs(dragStart.row - row);
              const colDiff = Math.abs(dragStart.col - col);

              if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                swapTiles(dragStart.row, dragStart.col, row, col);
              }
            }

            setDragStart(null);
            setDragCurrent(null);
          };

          const swapTiles = (row1, col1, row2, col2) => {
            const temp = gridRef.current[row1][col1];
            gridRef.current[row1][col1] = gridRef.current[row2][col2];
            gridRef.current[row2][col2] = temp;

            drawGrid();
            soundRef.current.playSwap();

            const matches = findAllMatches();
            if (matches.length > 0) {
              setMoves(m => m - 1);
              processMatches();
            } else {
              const temp = gridRef.current[row1][col1];
              gridRef.current[row1][col1] = gridRef.current[row2][col2];
              gridRef.current[row2][col2] = temp;
              drawGrid();
            }
          };

          const processMatches = () => {
            setIsAnimating(true);
            let totalScore = 0;
            let roundCount = 0;

            const processRound = () => {
              const matches = findAllMatches();

              if (matches.length > 0) {
                roundCount++;
                const maxMatchSize = Math.max(...matches.map(m => m.matchSize || 3));
                const points = matches.length * 10 * (roundCount > 1 ? roundCount : 1);
                totalScore += points;
                
                if (maxMatchSize >= 4) {
                  soundRef.current.playSpecial();
                } else {
                  soundRef.current.playMatch(matches.length);
                }

                if (roundCount > 1) {
                  soundRef.current.playCombo(roundCount);
                }

                const flashPositions = matches.map(m => ({ row: m.row, col: m.col }));
                setFlashCells(flashPositions);
                
                matches.forEach(({ row, col, type, matchSize }) => {
                  createParticles(row, col, matchSize || 3, type);
                  gridRef.current[row][col] = -1;
                });

                setTimeout(() => setFlashCells([]), 300);

                drawGrid();
                
                setTimeout(() => {
                  soundRef.current.playDrop();
                  dropCandies();
                  drawGrid();
                  
                  setTimeout(() => {
                    processRound();
                  }, 300);
                }, 400);
              } else {
                setScore(s => s + totalScore);
                if (roundCount >= 3) {
                  soundRef.current.playSuccess();
                }
                setIsAnimating(false);
              }
            };

            processRound();
          };

          const dropCandies = () => {
            for (let col = 0; col < GRID_SIZE; col++) {
              let writeRow = GRID_SIZE - 1;
              
              for (let row = GRID_SIZE - 1; row >= 0; row--) {
                if (gridRef.current[row][col] !== -1) {
                  gridRef.current[writeRow][col] = gridRef.current[row][col];
                  if (writeRow !== row) {
                    gridRef.current[row][col] = -1;
                  }
                  writeRow--;
                }
              }

              for (let row = writeRow; row >= 0; row--) {
                gridRef.current[row][col] = Math.floor(Math.random() * CANDY_TYPES);
              }
            }
          };

          const resetGame = () => {
            setScore(0);
            setMoves(30);
            setGameOver(false);
            setDragStart(null);
            setDragCurrent(null);
            setParticles([]);
            setComboCount(0);
            initializeGrid();
          };

          const toggleSound = () => {
            const newState = soundRef.current.toggleSound();
            setSoundEnabled(newState);
          };

          useEffect(() => {
            if (moves <= 0 && !isAnimating) {
              setGameOver(true);
              soundRef.current.playGameOver();
            }
          }, [moves, isAnimating]);

          useEffect(() => {
            drawGrid();
          });

          useEffect(() => {
            const interval = setInterval(() => {
              setParticles(prev => {
                return prev.map(p => ({
                  ...p,
                  x: p.x + p.vx,
                  y: p.y + p.vy,
                  vy: p.vy + 0.2,
                  life: p.life - 0.02
                })).filter(p => p.life > 0);
              });
            }, 16);

            return () => clearInterval(interval);
          }, []);

          return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-purple-900 to-purple-700 p-4">
              <div className="mb-4 text-center">
                <h1 className="text-4xl font-bold text-yellow-300 mb-2" style={{ textShadow: '3px 3px 0px #000' }}>
                  CANDY CRUSH
                </h1>
                <div className="flex gap-8 justify-center text-white text-xl font-bold items-center">
                  <div className="bg-purple-950 px-6 py-2 border-4 border-purple-400">
                    SCORE: {score}
                  </div>
                  <div className="bg-purple-950 px-6 py-2 border-4 border-purple-400">
                    MOVES: {moves}
                  </div>
                  <button
                    onClick={toggleSound}
                    className="bg-purple-950 px-4 py-2 border-4 border-purple-400 hover:bg-purple-800 transition"
                    title={soundEnabled ? "Sound ON" : "Sound OFF"}
                  >
                    {soundEnabled ? "ðŸ”Š" : "ðŸ”‡"}
                  </button>
                </div>
              </div>

              <div className="relative">
                <canvas
                  ref={canvasRef}
                  width={GRID_SIZE * TILE_SIZE}
                  height={GRID_SIZE * TILE_SIZE}
                  onMouseDown={handleStart}
                  onMouseMove={handleMove}
                  onMouseUp={handleEnd}
                  onMouseLeave={() => {
                    setDragStart(null);
                    setDragCurrent(null);
                  }}
                  onTouchStart={handleStart}
                  onTouchMove={handleMove}
                  onTouchEnd={handleEnd}
                  className="border-8 border-purple-400 cursor-pointer shadow-2xl"
                  style={{ imageRendering: 'pixelated', touchAction: 'none' }}
                />
                
                {particles.map(p => (
                  <div
                    key={p.id}
                    className="particle absolute rounded-full pointer-events-none"
                    style={{
                      left: p.x,
                      top: p.y,
                      width: p.size,
                      height: p.size,
                      backgroundColor: p.color,
                      opacity: p.life,
                      transform: 'translate(-50%, -50%)'
                    }}
                  />
                ))}
                
                {gameOver && (
                  <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center">
                    <div className="text-center">
                      <h2 className="text-4xl font-bold text-yellow-300 mb-4" style={{ textShadow: '3px 3px 0px #000' }}>
                        GAME OVER!
                      </h2>
                      <p className="text-2xl text-white mb-6">Final Score: {score}</p>
                      <button
                        onClick={resetGame}
                        className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 text-xl border-4 border-green-700"
                      >
                        PLAY AGAIN
                      </button>
                    </div>
                  </div>
                )}
              </div>

              <div className="mt-6 text-white text-center bg-purple-950 p-4 border-4 border-purple-400 max-w-md">
                <p className="font-bold mb-2">COMO JOGAR:</p>
                <p className="text-sm">Arraste um doce para trocar com um adjacente. Combine 3 ou mais da mesma cor para pontuar!</p>
                <p className="text-sm mt-2">âœ¨ Matches de 4+ criam efeitos especiais!</p>
              </div>
            </div>
          );
        };

        ReactDOM.render(<CandyCrush />, document.getElementById('root'));
    </script>
</body>
</html>
